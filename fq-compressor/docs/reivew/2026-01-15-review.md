# 设计评审报告 - 2026-01-15

## 概述

本文档记录了对 fq-compressor 项目设计方案的全面评审结果。评审范围包括：
- `design.md` - 设计文档
- `requirements.md` - 需求文档
- `tasks.md` - 实现计划
- `ref.md` - 参考项目文档

## 评审结论

整体设计质量较高，架构清晰，技术选型合理。发现 10 个需要修复的问题，其中：
- 🔴 严重问题: 2 个（影响正确性或一致性）
- 🟡 中等问题: 5 个（影响可用性或性能）
- 🟢 轻微问题: 3 个（文档不一致或缺失）

---

## 问题清单

### 问题 1: BlockHeader 缺少 codec_aux 字段 🟢

**严重程度**: 轻微  
**影响范围**: design.md - Block Structure  
**状态**: ✅ 已修复

#### 问题描述

BlockHeader 定义了 `offset_aux` 和 `size_aux` 字段用于存储辅助数据流（如可变长度 Reads 的长度信息），但缺少对应的 `codec_aux` 字段来指定该流的编码方式。

```cpp
// 当前定义 (不完整)
struct BlockHeader {
    // ...
    uint8_t  codec_id;    // ID 流编码
    uint8_t  codec_seq;   // Sequence 流编码
    uint8_t  codec_qual;  // Quality 流编码
    // 缺少 codec_aux
    
    uint64_t offset_aux;  // Aux 流偏移
    uint64_t size_aux;    // Aux 流大小
};
```

#### 影响分析

1. **一致性问题**: 其他三个流都有对应的 codec 字段，Aux 流缺失会导致设计不一致
2. **扩展性问题**: 未来如果需要更换 Aux 流的编码方式，没有字段来标识
3. **解码问题**: Reader 无法知道如何解码 Aux 流

#### 修复方案

在 BlockHeader 中添加 `codec_aux` 字段，并更新总大小计算。

---

### 问题 2: Global Checksum 校验范围不明确 🟡

**严重程度**: 中等  
**影响范围**: design.md - FileFooter  
**状态**: ✅ 已修复

#### 问题描述

FileFooter 中的 `global_checksum` 描述为"整个文件的 XXHASH64 (不含 Footer 本身)"，但未明确具体的校验范围：

- 是否包含 Magic Header？
- 是否包含 Global Header？
- 是否包含 Block Index？
- 是否包含 Reorder Map？

#### 影响分析

1. **实现歧义**: 不同开发者可能有不同理解，导致实现不一致
2. **互操作性**: 第三方工具无法正确验证文件完整性
3. **调试困难**: 校验失败时难以定位问题

#### 修复方案

明确定义校验范围为 `[文件起始, Footer 起始位置)`，即：
- Magic Header ✓
- Global Header ✓
- All Blocks ✓
- Reorder Map (if exists) ✓
- Block Index ✓
- File Footer ✗ (不包含)

---

### 问题 3: 两阶段策略与流式处理的冲突 🔴

**严重程度**: 严重  
**影响范围**: design.md, requirements.md  
**状态**: ✅ 已修复

#### 问题描述

两阶段压缩策略的 Phase 1 需要扫描所有 Reads 才能完成全局重排序，这与 stdin 流式输入存在根本冲突：

```
Phase 1: Global Analysis
├── 1.1 扫描所有 Reads，提取 Minimizers  ← 需要完整数据
├── 1.2 构建 Minimizer -> Bucket 映射
├── 1.3 全局重排序决策                    ← 需要完整数据
└── ...
```

#### 影响分析

1. **功能限制**: 无法支持 `cat file.fq | fqc compress -i - -o out.fqc` 的常见用法
2. **内存问题**: 对于 10 亿条 Reads，Phase 1 需要 ~24GB 内存（24 bytes/read）
3. **用户体验**: 用户可能期望支持管道输入，但实际会失败或产生次优结果

#### 修复方案

1. 在 requirements.md 中明确说明 stdin 输入的限制和行为
2. 添加 `--streaming` 模式选项，禁用全局重排序，仅做 Block 内局部优化
3. 当检测到 stdin 输入且未指定 `--streaming` 时，自动启用流式模式并发出警告

---

### 问题 4: PE_LAYOUT 标志位语义重叠 🟡

**严重程度**: 中等  
**影响范围**: design.md - Global Header Flags  
**状态**: ✅ 已修复

#### 问题描述

`PE_LAYOUT` (bit 8-9) 与 `IS_PAIRED` (bit 0) 存在语义重叠：

```
当前定义:
- bit 0: IS_PAIRED
- bit 8-9: PE_LAYOUT
    - 00: Single-End      ← 与 IS_PAIRED=0 重复
    - 01: Interleaved
    - 10: Consecutive
```

问题场景：
- 当 `IS_PAIRED=0` 时，`PE_LAYOUT` 的值应该被忽略
- 当 `IS_PAIRED=1` 时，`PE_LAYOUT=00 (Single-End)` 是无效/矛盾状态

#### 影响分析

1. **状态空间浪费**: 存在无效的标志位组合
2. **验证复杂性**: Reader 需要额外逻辑处理矛盾状态
3. **潜在 Bug**: 可能产生 `IS_PAIRED=1, PE_LAYOUT=00` 的无效文件

#### 修复方案

重新定义 `PE_LAYOUT` 语义，仅在 `IS_PAIRED=1` 时有效：
```
bit 8-9: PE_LAYOUT (仅当 IS_PAIRED=1 时有效)
  00: Interleaved (默认，R1/R2 交替存储)
  01: Consecutive (所有 R1 后跟所有 R2)
  10-11: Reserved
```

---

### 问题 5: Reorder Map 查询效率问题 🟡

**严重程度**: 中等  
**影响范围**: design.md - Reorder Map  
**状态**: ✅ 已修复

#### 问题描述

当前 Reorder Map 存储 `original_id -> archive_id` 映射，使用 Delta + Varint 编码。但解压时的需求是：

| 场景 | 需要的映射方向 | 当前支持 |
|------|---------------|---------|
| 按归档顺序解压 | 无需映射 | ✓ |
| 按原始顺序输出 | `archive_id -> original_id` | ✗ |
| 查询原始 Read 位置 | `original_id -> archive_id` | ✓ |

Delta + Varint 编码是顺序访问优化的，不支持高效的：
1. 反向查询（给定 archive_id 找 original_id）
2. 随机访问（给定 original_id 直接定位）

#### 影响分析

1. **性能问题**: `--original-order` 解压需要 O(N) 时间构建反向索引
2. **内存问题**: 反向索引需要额外 O(N) 内存
3. **用户体验**: 大文件的原始顺序解压可能非常慢

#### 修复方案

1. 存储双向映射（推荐）：
   - Forward Map: `original_id -> archive_id` (用于查询)
   - Reverse Map: `archive_id -> original_id` (用于原始顺序输出)
   - 空间开销: ~4 bytes/read (两个映射都用 Delta 编码)

2. 在文档中明确 `--original-order` 的性能预期

---

### 问题 6: Long Read 阈值定义不一致 🔴

**严重程度**: 严重  
**影响范围**: design.md, requirements.md  
**状态**: ✅ 已修复

#### 问题描述

文档中对 Read 长度分类存在多处不一致：

| 位置 | Short Read 定义 | Long Read 定义 |
|------|----------------|----------------|
| design.md (Long Read 策略) | - | read length > 10KB |
| design.md (自动检测) | - | median length > 10KB |
| requirements.md | length < 512bp | 任意长度 |
| design.md (Block Size) | 100K reads | 10K reads |

问题：
- 512bp 和 10KB 之间的 Reads 如何分类？（如 PacBio HiFi ~15KB, MiSeq 2x300bp）
- "read length > 10KB" vs "median length > 10KB" 是不同的判断标准

#### 影响分析

1. **实现歧义**: 开发者不知道该用哪个阈值
2. **边界情况**: 中等长度 Reads 的处理策略不明确
3. **用户困惑**: 文档自相矛盾

#### 修复方案

统一定义三级分类：
```
Short Read:  median < 1KB
  - 使用 ABC + 全局 Reordering
  - Block Size: 100K reads

Medium Read: 1KB <= median < 10KB
  - 使用 ABC + 可选 Reordering (默认启用)
  - Block Size: 50K reads

Long Read:   median >= 10KB
  - 禁用 Reordering
  - 使用 Overlap-based 或 Zstd
  - Block Size: 10K reads
```

---

### 问题 7: Aux Stream 编码规范缺失 🟡

**严重程度**: 中等  
**影响范围**: design.md - Block Structure  
**状态**: ✅ 已修复

#### 问题描述

BlockHeader 定义了 `offset_aux` 和 `size_aux`，但未说明：
1. Aux Stream 的具体用途
2. 何时需要存储（固定长度 vs 可变长度 Reads）
3. 编码方式
4. 当不需要时如何表示

#### 影响分析

1. **实现不确定性**: 开发者不知道如何实现 Aux Stream
2. **空间浪费**: 可能存储不必要的数据
3. **兼容性问题**: 不同实现可能不兼容

#### 修复方案

明确定义 Aux Stream 规范：
```
Aux Stream 用途:
1. 存储可变长度 Reads 的长度信息
2. 存储其他辅助元数据 (预留扩展)

存储条件:
- 当 Block 内所有 Reads 长度相同时: size_aux = 0
- 当 Reads 长度不同时: 存储 Delta + Varint 编码的长度序列

编码方式:
- codec_aux = 0x30 (DELTA_VARINT)
- 第一个长度存储原值，后续存储与前一个的差值
```

---

### 问题 8: Tasks.md 中 Block 大小默认值不一致 🟢

**严重程度**: 轻微  
**影响范围**: tasks.md - Task 12.2  
**状态**: ✅ 已修复

#### 问题描述

```
tasks.md (Task 12.2):
  "配置 Block 大小 (默认 10000 reads)"

design.md & requirements.md:
  "每 Block 默认 100K reads"
  "--block-reads <N>: 每个 Block 的 reads 数（默认：100000）"
```

差异: 10,000 vs 100,000 (10倍差距)

#### 影响分析

1. **实现错误**: 可能按错误的默认值实现
2. **性能影响**: Block 大小影响压缩率和随机访问粒度

#### 修复方案

统一为：
- Short Read: 100,000 reads/block
- Medium Read: 50,000 reads/block
- Long Read: 10,000 reads/block

---

### 问题 9: Codec 注册表不完整 🟡

**严重程度**: 中等  
**影响范围**: design.md - Codec Versioning  
**状态**: ✅ 已修复

#### 问题描述

当前 Codec Family 定义不完整：
1. 只定义了 5 个 Family (0x0-0x4, 0xF)
2. 缺少 Aux Stream 的 Codec
3. 未说明 Codec 参数如何存储（如 SCM 的 Order 参数）

#### 影响分析

1. **扩展性受限**: 新增 Codec 时没有明确的注册流程
2. **参数传递**: 某些 Codec 需要参数，但没有存储位置

#### 修复方案

1. 扩展 Codec Family 注册表
2. 添加 Codec 参数存储机制（在 GlobalHeader 中添加可选的 CodecParams 段）

---

### 问题 10: 缺少错误恢复策略 🟡

**严重程度**: 中等  
**影响范围**: requirements.md - Requirement 8  
**状态**: ✅ 已修复

#### 问题描述

当前设计有原子写入和信号处理，但缺少：
1. 部分损坏文件的恢复策略
2. Block 级别的错误隔离机制
3. 损坏 Block 的跳过选项

#### 影响分析

1. **数据丢失**: 单个 Block 损坏可能导致整个文件无法使用
2. **用户体验**: 无法从部分损坏的文件中恢复数据

#### 修复方案

添加 Requirement 8.5 - 错误隔离与恢复：
1. 单个 Block 损坏不影响其他 Block 解压
2. verify 命令报告所有损坏 Block 位置
3. decompress 支持 `--skip-corrupted` 选项

---

## 修复摘要

| 问题 | 修复文件 | 修复内容 |
|------|----------|----------|
| #1 | design.md | 添加 codec_aux 字段，更新 BlockHeader 大小 |
| #2 | design.md | 明确 global_checksum 校验范围 |
| #3 | design.md, requirements.md | 添加流式模式说明和 --streaming 选项 |
| #4 | design.md | 重新定义 PE_LAYOUT 语义 |
| #5 | design.md | 添加双向 Reorder Map 设计 |
| #6 | design.md, requirements.md | 统一 Read 长度分类定义 |
| #7 | design.md | 添加 Aux Stream 编码规范 |
| #8 | tasks.md | 统一 Block 大小默认值 |
| #9 | design.md | 扩展 Codec 注册表 |
| #10 | requirements.md | 添加错误隔离需求 |

---

## 评审人

- 评审日期: 2026-01-15
- 评审工具: Kiro AI Assistant
